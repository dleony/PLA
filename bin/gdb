#!/usr/bin/python
# -*- coding: UTF-8 -*-#
#
# Author: Abelardo Pardo (abelardo.pardo@uc3m.es)
#
import os, sys, subprocess, datetime

import PLABasic

dataDir = os.path.join(PLABasic.plaDirectory, 'tools', 'gdb')
dataFile = os.path.join(__gccDataDir, 'gdblog.txt')

def main(): 
    """
    Application to wrap the execution of the gdb debugger. Execute it normally
    and record its invocation.
    """
    
    global dataDir
    global dataFile

    PLABasic.logMessage("gdb: plaDirectory = " + PLABasic.plaDirectory)
    PLABasic.logMessage("gdb: DataDir = " + dataDir)
    PLABasic.logMessage("gdb: DataFile = " + dataFile)


    # Modify the first argument to point to the true executable
    sys.argv[0] = '/usr/bin/gdb'

    # Execute the given gdb command regularly
    try:
        PLABasic.logMessage('gdb: executing ' + str(sys.argv))
        givenCmd = subprocess.Popen(sys.argv)
    except OSError, e:		  
        print 'File not found (PLA)'
        sys.exit(0)
    except ValueError, e:
        print 'Incorrect arguments (PLA)'
        sys.exit(0)
        
    # Wait for the process to terminate
    givenCmd.wait()

    # Store the return status to return when the script finishes.
    originalStatus = givenCmd.returncode
    PLABasic.logMessage('gdb: command status = ' + str(originalStatus))

    # If no file is present in pladirectory, no instrumentation
    if not os.path.exists(dataDir):
        PLABasic.logMessage("gdb: Disabled. Skipping")
        sys.exit(originalStatus)

    # Append the captured messages to the file with a separator
    gdbDataOut = open(dataFile, 'a')

    # Dump a mark status and time/date
    gdbDataOut.write(str(originalStatus) + ' ' \
                         + str(datetime.datetime.now())[:-7] + '\n')
    gdbDataOut.close()

    # And terminate gracefully with the status generated by the original SVN
    sys.exit(originalStatus)

if __name__ == "__main__":
    main()
