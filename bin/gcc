#!/usr/bin/python
# -*- coding: UTF-8 -*-#
#
# Author: Abelardo Pardo (abelardo.pardo@uc3m.es)
#
import os, sys, subprocess, datetime

import PLABasic

__gccDataDir = os.path.join(PLABasic.plaDirectory, 'tools', 'gcc')
__gccDataFile = os.path.join(__gccDataDir, 'gcclog.txt')

def main(): 
    """
    Application to wrap the execution of the gcc compiler. Execute it regularly
    and then parse the obtained ouptput and error streams.
    """
    
    global __gccDataDir
    global __gccDataFile

    PLABasic.logMessage("gcc: plaDirectory = " + PLABasic.plaDirectory)

    # Modify the first argument to point to the true executable
    sys.argv[0] = '/usr/bin/gcc'

    # Execute the given gcc command regularly
    try:
        PLABasic.logMessage('gcc: executing ' + str(sys.argv))
        givenCmd = subprocess.Popen(sys.argv, stdout = subprocess.PIPE,
                                    stderr = subprocess.PIPE)
    except OSError, e:		  
        print 'File not found (PLA)'
        sys.exit(0)
    except ValueError, e:
        print 'Incorrect arguments (PLA)'
        sys.exit(0)
        
    # Wait for the process to terminate and get the output/error
    (gccOutput, gccError) = givenCmd.communicate()

    # Original command is execute, store the return status to return when
    # the script finishes.
    originalStatus = givenCmd.returncode
    PLABasic.logMessage('gcc: command status = ' + str(originalStatus))

    # Dump output and error if not None
    if gccError != None:
        PLABasic.logMessage('gcc: stderr string')
        sys.stderr.write(gccError)
    else:
        PLABasic.logMessage('gcc: No error string')

    if gccOutput != None:
        PLABasic.logMessage('gcc: stdout string')
        sys.stdout.write(gccOutput)
    else:
        PLABasic.logMessage('gcc: No output string')

    # If no file is present in pladirectory, no instrumentation
    if not os.path.exists(__gccDataDir):
        PLABasic.logMessage("gcc: Disabled. Skipping")
        sys.exit(originalStatus)

    # Append the captured messages to the file with a separator
    gccDataOut = open(__gccDataFile, 'a')

    # Dumpt a mark for the erro with lines outputlines status and time/date
    errorLines = gccError.count('\n')
    outputLines = gccOutput.count('\n') 
    gccDataOut.write('-E ' + str(originalStatus) + ' ' \
                         + str(errorLines) + ' ' \
                         + str(outputLines) + ' ' \
                         + str(datetime.datetime.now())[:-7] + '\n')
    if errorLines != 0:
        gccDataOut.write(str(gccError))

    # Dump the output only if it is not empty
    if outputLines != 0:
        gccDataOut.write('-O ' + str(outputLines) + '\n')
        gccDataOut.write(str(gccOutput))
    gccDataOut.close()

    # And terminate gracefully with the status generated by the original SVN
    sys.exit(originalStatus)

def instrument():
    global __gccDataDir
    global __gccDataFile

    # If no file is present in pladirectory, nothing to return
    if not os.path.exists(__gccDataDir):
        PLABasic.logMessage("gcc-instrument: Disabled. Skipping")
        return []

    # If the log file does not exist, nothing to do
    if not os.path.exists(__gccDataFile):
        return []

    # If the file is present, but it is empty (because we reset it, done
    if os.path.getsize(__gccDataFile) == 0:
        return []

    return [__gccDataFile]

def resetData():
    global __gccDataDir
    global __gccDataFile

    # If no file is present in pladirectory, nothing to return
    if not os.path.exists(__gccDataDir):
        PLABasic.logMessage("gcc.instrument: Disabled. Skipping")
        return []

    # If the log file does not exist, nothing to do
    if not os.path.exists(__gccDataFile):
        return []

    # If the file is present, but it is empty (because we reset it, done
    if os.path.getsize(__gccDataFile) == 0:
        return []

    PLABasic.logMessage("gcc.instrument: Removing " + __gccDataFile)
    fobj = open(__gccDataFile, 'w')
    fobj.close()

if __name__ == "__main__":
    main()
